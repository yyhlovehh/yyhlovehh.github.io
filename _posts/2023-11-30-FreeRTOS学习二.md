# FreeRTOS学习二

## 1、任务调度器

## 2、任务状态查询API函数

![6_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302322616.png)

![6_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302324291.png)

## 3、延时函数

![7_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302333620.png)

绝对延时：整个任务运行时间是固定的。

## 4、消息队列

**任务到任务、任务到中断、中断到任务数据交流的一种机制。**

![8_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302339635.png)

![8_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302345226.png)

![8_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202311302346257.png)

![8_4](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010001019.png)

![8_5](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010005927.png)

![8_6](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010006877.png)

先入先出FIFO:

![8_7](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010007622.png)

队列结构体：

pcHead:存储区域的起始地址，即队列项的起始地址；

pcWriteTo:下一个写入的位置；

uxMessagesWaiting:非空闲队列项目的数量；

uxLength:队列长度，即队列项目的数量；

uxItemSize:队列项目的大小，一个队列占多少字节；

![8_9](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010021295.png)

看图理解各成员：

![8_8](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312010023166.png)

![8_11](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011151321.png)

![8_12](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011151259.png)

![8_13](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011152563.png)

![8_14](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011152607.png)

## 5、信号量

**信号量：传递状态；**

![9_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011202215.png)

![9_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011202292.png)

![9_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011204110.png)

### 5.1二值信号量

- 互斥访问:存在优先级翻转问题。
- **任务同步：一个任务必须等待另一个任务完成后才能进行，更适用于任务同步。**
- 支持任务Task和中断ISR
- 释放信号量，非空队列项目为1，获取信号量，非空队列项目为0。
- 本质上是一个队列长度为1的队列，即队列项目总数为1。

![9_4](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011207598.png)

![9_5](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011212028.png)

### 5.2计数型信号量

![9_6](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011330858.png)

![9_7](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011338140.png)

### 5.3优先级翻转

使用二值信号量经常遇到优先级翻转问题。

![9_8](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011354964.png)

![9_9](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011355609.png)

任务H最高优先级，获取信号量，任务M次优先级，不获取信号量，任务L最低优先级，获取信号量。如果一开始，任务L就绪，H、M未就绪，那么任务L获取信号量，之后任务H就绪，无法获取信号量进入阻塞，之后任务M就绪，无需获取信号量也可以执行，就会抢占CPU，如果任务M运行时间长，则任务L很晚释放信号量,高优先级任务反而不能执行。

### 5.4互斥信号量

**什么叫优先级继承？**

![9_10](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011403005.png)

![9_11](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011404582.png)

![9_12](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011408834.png)

![9_13](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011408264.png)

## 6.队列集

一个任务有多个队列，队列集对多个队列或信号量进行监听。

![10_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011430604.png)

![10_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011432359.png)

## 7.事件标志组

![11_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011435160.png)

![11_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011438479.png)![11_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011439801.png)

![11_4](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011439795.png)

![11_5](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011441057.png)

## 8.任务通知

优点是消耗内存小，不需要像队列、信号量、事件标志组另外创建。

![12_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011452015.png)

![12_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011454874.png)

![12_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011455443.png)

ISR:中断。

## 9.软件定时器

什么是软件定时器？

![13_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011502588.png)

![13_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011502146.png)

![13_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312011503866.png)

## 10.内存管理

动态创建比较自动化、灵活。

![14_1](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312061631432.png)

![14_2](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312061633929.png)

![14_3](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312061636068.png)

heap1:适合只创建、不擅除的场景。

![14_4](https://raw.githubusercontent.com/yyhlovehh/yyhlovehh.github.io/master/202312061640416.png)